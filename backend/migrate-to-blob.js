// Local uploads klas√∂r√ºndeki dosyalarƒ± Vercel Blob'a y√ºkle
require('dotenv').config();
const { put } = require('@vercel/blob');
const fs = require('fs');
const path = require('path');
const mongoose = require('mongoose');
const Profile = require('./models/Profile');
const Project = require('./models/Project');

const uploadsDir = path.join(__dirname, 'uploads');

async function uploadFilesToBlob() {
    try {
        if (!process.env.BLOB_READ_WRITE_TOKEN) {
            console.error('‚ùå BLOB_READ_WRITE_TOKEN environment variable gerekli!');
            console.log('Vercel Dashboard ‚Üí Storage ‚Üí Blob ‚Üí Connect to get token');
            process.exit(1);
        }

        // MongoDB'e baƒülan
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('‚úÖ MongoDB baƒülantƒ±sƒ± ba≈üarƒ±lƒ±\n');

        // Uploads klas√∂r√º var mƒ± kontrol et
        if (!fs.existsSync(uploadsDir)) {
            console.log('‚ùå Uploads klas√∂r√º bulunamadƒ±');
            process.exit(1);
        }

        const files = fs.readdirSync(uploadsDir);
        console.log(`üìÅ ${files.length} dosya bulundu\n`);

        const urlMap = {}; // old URL -> new Blob URL mapping

        // Her dosyayƒ± Blob'a y√ºkle
        for (const filename of files) {
            const filePath = path.join(uploadsDir, filename);
            const fileBuffer = fs.readFileSync(filePath);
            
            console.log(`‚è≥ Y√ºkleniyor: ${filename}...`);
            
            const blob = await put(filename, fileBuffer, {
                access: 'public',
                token: process.env.BLOB_READ_WRITE_TOKEN,
            });

            const oldUrl = `http://localhost:3000/uploads/${filename}`;
            const renderUrl = `https://portfolioproject-gigt.onrender.com/uploads/${filename}`;
            urlMap[oldUrl] = blob.url;
            urlMap[renderUrl] = blob.url;
            
            console.log(`   ‚úÖ ${blob.url}\n`);
        }

        console.log('üîÑ MongoDB URL\'lerini g√ºncelleniyor...\n');

        // Profile URL'lerini g√ºncelle
        const profile = await Profile.findOne();
        if (profile) {
            let updated = false;

            if (profile.avatarUrl && urlMap[profile.avatarUrl]) {
                profile.avatarUrl = urlMap[profile.avatarUrl];
                updated = true;
            }

            if (profile.cvUrl && urlMap[profile.cvUrl]) {
                profile.cvUrl = urlMap[profile.cvUrl];
                updated = true;
            }

            if (profile.techStack) {
                profile.techStack.forEach(tech => {
                    if (tech.icon && tech.icon.startsWith('custom:')) {
                        const iconUrl = tech.icon.replace('custom:', '');
                        if (urlMap[iconUrl]) {
                            tech.icon = `custom:${urlMap[iconUrl]}`;
                            updated = true;
                        }
                    }
                });
            }

            if (updated) {
                await profile.save();
                console.log('‚úÖ Profile URL\'leri g√ºncellendi');
            }
        }

        // Project URL'lerini g√ºncelle
        const projects = await Project.find();
        let projectCount = 0;
        for (const project of projects) {
            if (project.imageUrl && urlMap[project.imageUrl]) {
                project.imageUrl = urlMap[project.imageUrl];
                await project.save();
                projectCount++;
            }
        }
        if (projectCount > 0) {
            console.log(`‚úÖ ${projectCount} proje URL'i g√ºncellendi`);
        }

        console.log('\nüéâ T√ºm dosyalar Vercel Blob\'a y√ºklendi ve MongoDB g√ºncellendi!');
        console.log('\nüìã URL Mapping:');
        Object.entries(urlMap).forEach(([old, newUrl]) => {
            console.log(`   ${path.basename(old)} -> ${newUrl}`);
        });

        process.exit(0);
    } catch (error) {
        console.error('‚ùå Hata:', error);
        process.exit(1);
    }
}

uploadFilesToBlob();
